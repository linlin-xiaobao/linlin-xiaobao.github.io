<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
    <title>无畏契约：小琳特供版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="./index.css" />
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Teko:wght@300;400;500;600;700&display=swap');
      /* Ensure loading overlay covers everything */
      .loading-screen { position: fixed; inset: 0; background: #0f1923; z-index: 100; display: flex; justify-content: center; align-items: center; color: white; }
    </style>
    
    <!-- 1. Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 2. Import Maps for modules -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.1/",
    "react/": "https://aistudiocdn.com/react@^19.2.1/"
  }
}
</script>

    <!-- 3. MediaPipe Global Scripts -->
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>

    <!-- MAIN APPLICATION LOGIC -->
    <script type="text/babel" data-type="module" data-presets="react, typescript">
      import React, { useState, useEffect, useRef } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';

      // --- UTILS: Sound ---
      let audioCtx = null;
      const getCtx = () => {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioCtx;
      };

      const generateSound = (type) => {
        const ctx = getCtx();
        if (ctx.state === 'suspended') ctx.resume();

        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        const now = ctx.currentTime;

        switch (type) {
          case 'shoot':
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(880, now);
            osc.frequency.exponentialRampToValueAtTime(110, now + 0.15);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.start(now);
            osc.stop(now + 0.15);
            break;
          case 'hit':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(1200, now);
            osc.frequency.exponentialRampToValueAtTime(2000, now + 0.05);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            
            // Crunch
            const osc2 = ctx.createOscillator();
            const gain2 = ctx.createGain();
            osc2.type = 'square';
            osc2.frequency.setValueAtTime(100, now);
            osc2.connect(gain2);
            gain2.connect(ctx.destination);
            gain2.gain.setValueAtTime(0.2, now);
            gain2.gain.linearRampToValueAtTime(0, now + 0.05);
            osc2.start(now);
            osc2.stop(now + 0.05);
            
            osc.start(now);
            osc.stop(now + 0.1);
            break;
          case 'miss':
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.2);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
            break;
          case 'ui':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.setValueAtTime(1200, now + 0.05);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
            break;
        }
      };

      // --- COMPONENT: ARGame ---
      const MP_HANDS_VERSION = '0.4.1646424915';

      function ARGame({ gameState, onScoreUpdate, onGameOver }) {
        const containerRef = useRef(null);
        const videoRef = useRef(null);
        const canvasRef = useRef(null);
        const trackingCanvasRef = useRef(null);
        
        // Game Logic Refs
        const sceneRef = useRef(null);
        const cameraRef = useRef(null);
        const rendererRef = useRef(null);
        const targetsRef = useRef([]);
        const laserRef = useRef(null);
        const reticleRef = useRef(null);
        const muzzleFlashRef = useRef(null);
        const droneTextureRef = useRef(null);
        
        const scoreRef = useRef(0);
        const isTriggeredRef = useRef(false);
        const lastShotTimeRef = useRef(0);
        const latestLandmarksRef = useRef(null);
        const handsRef = useRef(null);
        
        // Processing State
        const processingRef = useRef(false);
        const lastProcessTimeRef = useRef(0);
        
        // State
        const [initialized, setInitialized] = useState(false);
        const [logs, setLogs] = useState([]);
        const [cameraError, setCameraError] = useState(null);
        const [cameraReady, setCameraReady] = useState(false);
        const [floatingTexts, setFloatingTexts] = useState([]);
        const recoilRef = useRef({ x: 0, y: 0, decay: 0.85 });

        const log = (msg) => {
          console.log(msg);
          setLogs(prev => [msg, ...prev].slice(0, 5));
        };

        const addFloatingText = (x, y, text, type) => {
          const id = Date.now() + Math.random();
          setFloatingTexts(prev => [...prev, { id, x, y, text, type }]);
          setTimeout(() => setFloatingTexts(prev => prev.filter(ft => ft.id !== id)), 800);
        };

        const createDroneTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            if (ctx) {
                const grad = ctx.createRadialGradient(128,128,40, 128,128,120);
                grad.addColorStop(0, 'rgba(0, 255, 255, 1)');
                grad.addColorStop(0.5, 'rgba(0, 100, 100, 0.5)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,256,256);
                
                ctx.beginPath();
                ctx.arc(128, 128, 40, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                
                ctx.strokeStyle = '#ff4655';
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.arc(128, 128, 60, 0, Math.PI * 1.5);
                ctx.stroke();

                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(128, 128, 75, Math.PI, Math.PI * 2.5);
                ctx.stroke();
            }
            const tex = new THREE.CanvasTexture(canvas);
            droneTextureRef.current = tex;
            return tex;
        };

        const startSystem = async () => {
          if (initialized) return;
          setInitialized(true);
          log("System Initializing...");

          try { generateSound('ui'); } catch(e) {}

          try {
              if (!window.Hands) {
                  log("Waiting for MediaPipe...");
                  await new Promise(r => setTimeout(r, 1000));
                  if (!window.Hands) throw new Error("MediaPipe script failed to load");
              }
              
              const hands = new window.Hands({
                locateFile: (file) => `https://unpkg.com/@mediapipe/hands@${MP_HANDS_VERSION}/${file}`
              });
              
              hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
              });
              
              // Note: We ONLY update data here. Rendering happens in the loop.
              hands.onResults((results) => {
                 latestLandmarksRef.current = results.multiHandLandmarks?.length ? results.multiHandLandmarks[0] : null;
              });
              handsRef.current = hands;
              log("AI Core Online");
          } catch (e) {
              log("AI ERROR: " + e.message);
              setCameraError("AI CORE FAILED");
          }

          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
             let stream;
             log("Requesting Sensors...");
             try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } }, 
                    audio: false 
                });
             } catch (e) {
                try {
                    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
                } catch (e2) {
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                    } catch(e3) {
                        log("FATAL: No Sensors");
                        setCameraError("NO CAMERA FOUND");
                        return;
                    }
                }
             }
             
             if (videoRef.current && stream) {
                 videoRef.current.srcObject = stream;
                 videoRef.current.onloadedmetadata = () => {
                     videoRef.current.play()
                      .then(() => log("Video Feed Active"))
                      .catch(e => {
                          log("Play Blocked: " + e.message);
                          setCameraError("CAMERA PERMISSION BLOCKED");
                      });
                 };
             }
          } else {
              setCameraError("BROWSER UNSUPPORTED");
          }
        };

        useEffect(() => {
          if (!containerRef.current || !canvasRef.current) return;

          let animationFrameId;
          let clock = new THREE.Clock();

          const width = containerRef.current.clientWidth || window.innerWidth;
          const height = containerRef.current.clientHeight || window.innerHeight;

          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0x0f1923);

          const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
          scene.add(ambientLight);
          const dirLight = new THREE.DirectionalLight(0xff4655, 3);
          dirLight.position.set(-5, 5, 5);
          scene.add(dirLight);

          const aspect = width / height;
          const threeCamera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
          threeCamera.position.z = 10; 

          const renderer = new THREE.WebGLRenderer({ 
            canvas: canvasRef.current, 
            alpha: true,
            antialias: true
          });
          renderer.setSize(width, height);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

          sceneRef.current = scene;
          cameraRef.current = threeCamera;
          rendererRef.current = renderer;
          
          createDroneTexture();

          const gridHelper = new THREE.GridHelper(200, 50, 0x00ffff, 0x1a2b3c);
          gridHelper.position.y = -20;
          gridHelper.material.transparent = true;
          gridHelper.material.opacity = 0.15;
          scene.add(gridHelper);
          
          const laserMat = new THREE.LineBasicMaterial({ color: 0xff4655, linewidth: 2, transparent: true, opacity: 0.8 });
          const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-100)]);
          const laserLine = new THREE.Line(laserGeo, laserMat);
          laserLine.frustumCulled = false;
          scene.add(laserLine);
          laserRef.current = laserLine;

          const flashGeo = new THREE.PlaneGeometry(3, 3);
          const canvas = document.createElement('canvas');
          canvas.width = 64; canvas.height = 64;
          const ctx = canvas.getContext('2d');
          if (ctx) {
              const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
              grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
              grad.addColorStop(0.3, 'rgba(255, 200, 100, 0.8)');
              grad.addColorStop(1, 'rgba(255, 70, 85, 0)'); 
              ctx.fillStyle = grad;
              ctx.fillRect(0,0,64,64);
          }
          const flashTex = new THREE.CanvasTexture(canvas);
          const flashMat = new THREE.MeshBasicMaterial({ 
              map: flashTex, transparent: true, opacity: 0, depthTest: false, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
          });
          const muzzleFlash = new THREE.Mesh(flashGeo, flashMat);
          muzzleFlash.visible = false;
          scene.add(muzzleFlash);
          muzzleFlashRef.current = muzzleFlash;

          const reticleGroup = new THREE.Group();
          reticleGroup.add(new THREE.Mesh(new THREE.CircleGeometry(0.08, 16), new THREE.MeshBasicMaterial({ color: 0x00ffff })));
          reticleGroup.add(new THREE.Mesh(new THREE.RingGeometry(0.4, 0.45, 32), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 })));
          scene.add(reticleGroup);
          reticleRef.current = reticleGroup;

          let videoTexture = null;

          const spawnTarget = () => {
            const group = new THREE.Group();
            if (droneTextureRef.current) {
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: droneTextureRef.current, color: 0xffffff, blending: THREE.AdditiveBlending }));
                sprite.scale.set(3, 3, 1);
                group.add(sprite);
            }
            group.add(new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.05, 8, 32), new THREE.MeshBasicMaterial({ color: 0xff4655, wireframe: true })));

            const angle = (Math.random() - 0.5) * Math.PI * 1.5; 
            group.position.set(Math.sin(angle) * 25, (Math.random() - 0.5) * 12, -30 + (Math.random() * 5));
            group.userData = {
              velocity: new THREE.Vector3(0,0,1).applyEuler(new THREE.Euler(0, -angle, 0)).multiplyScalar(5 + Math.random() * 4), 
              active: true,
              rotSpeed: (Math.random() - 0.5) * 5
            };
            scene.add(group);
            targetsRef.current.push(group);
          };

          const loop = () => {
            if (!sceneRef.current) return;
            const dt = clock.getDelta();
            const elapsed = clock.getElapsedTime();
            const now = Date.now();

            // --- VIDEO & TRACKING UPDATE ---
            if (videoRef.current && videoRef.current.readyState >= 2) {
               // 1. Update ThreeJS Background
               if (!videoTexture) {
                   videoTexture = new THREE.VideoTexture(videoRef.current);
                   videoTexture.colorSpace = THREE.SRGBColorSpace;
               }
               if (videoTexture && !cameraReady) {
                 scene.background = videoTexture;
                 setCameraReady(true);
               }

               // 2. Draw Tracking View (Force update every frame)
               // This ensures the bottom-right view is smooth even if AI is lagging
               if (trackingCanvasRef.current) {
                  const ctx = trackingCanvasRef.current.getContext('2d');
                  if (ctx) {
                      const w = trackingCanvasRef.current.width;
                      const h = trackingCanvasRef.current.height;
                      
                      // Draw Video
                      ctx.save();
                      ctx.scale(-1, 1);
                      ctx.translate(-w, 0);
                      ctx.drawImage(videoRef.current, 0, 0, w, h);
                      ctx.restore();
                      
                      // Overlay Style
                      ctx.fillStyle = "rgba(0, 255, 255, 0.1)";
                      ctx.fillRect(0,0,w,h);
                      
                      // Draw Last Known Landmarks
                      const l = latestLandmarksRef.current;
                      if (l && window.drawConnectors) {
                           ctx.save();
                           ctx.scale(-1, 1);
                           ctx.translate(-w, 0);
                           window.drawConnectors(ctx, l, window.HAND_CONNECTIONS, {color: '#00ffff', lineWidth: 2});
                           ctx.restore();
                      }
                  }
               }

               // 3. Send to AI (Throttled)
               // Safety reset: If AI hangs for > 2 seconds, force unlock
               if (processingRef.current && (now - lastProcessTimeRef.current > 2000)) {
                   processingRef.current = false;
               }

               // Limit AI checks to ~15 FPS to save mobile resources
               if (handsRef.current && !processingRef.current && (now - lastProcessTimeRef.current > 60)) { 
                  processingRef.current = true;
                  lastProcessTimeRef.current = now;
                  handsRef.current.send({image: videoRef.current})
                    .then(() => { processingRef.current = false; })
                    .catch(() => { processingRef.current = false; });
               }
            }
            // -------------------------------

            recoilRef.current.x *= recoilRef.current.decay;
            recoilRef.current.y *= recoilRef.current.decay;
            cameraRef.current.rotation.x = recoilRef.current.y * 0.1;
            cameraRef.current.rotation.y = recoilRef.current.x * 0.1;

            if (gameState === 1) { // Playing
              if (targetsRef.current.length < 4 && Math.random() < 0.05) spawnTarget();

              for (let i = targetsRef.current.length - 1; i >= 0; i--) {
                const target = targetsRef.current[i];
                if (target.userData.active) {
                  target.position.add(target.userData.velocity.clone().multiplyScalar(dt));
                  target.children[1].rotation.x += dt * 2;
                  target.children[1].rotation.y += dt * target.userData.rotSpeed;
                  target.scale.setScalar(1 + Math.sin(elapsed * 5) * 0.1);

                  if (target.position.z > 5) {
                    scene.remove(target);
                    targetsRef.current.splice(i, 1);
                    generateSound('miss');
                    
                    const vector = target.position.clone().project(cameraRef.current);
                    const x = (vector.x * .5 + .5) * containerRef.current.clientWidth;
                    const y = (-(vector.y * .5) + .5) * containerRef.current.clientHeight;
                    addFloatingText(x, y, "MISS", "miss");
                  }
                }
              }

              const landmarks = latestLandmarksRef.current;
              let isShooting = false;
              
              if (landmarks) {
                const indexTip = landmarks[8];
                const indexMCP = landmarks[5];
                const thumbTip = landmarks[4];
                const ndcX = -(1 - indexTip.x) * 2 + 1;
                const ndcY = -(indexTip.y * 2 - 1);
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(ndcX, ndcY), cameraRef.current);
                
                const vec = new THREE.Vector3(ndcX, ndcY, 0.5).unproject(cameraRef.current);
                vec.sub(cameraRef.current.position).normalize();
                const handPos = cameraRef.current.position.clone().add(vec.multiplyScalar(3));

                let aimPoint = raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(50));
                let closestTarget = null;
                let minDist = 3.0; 

                targetsRef.current.forEach(target => {
                  const dist = raycaster.ray.distanceSqToPoint(target.position);
                  if (dist < minDist) { minDist = dist; closestTarget = target; }
                });

                if (closestTarget) {
                  aimPoint.copy(closestTarget.position);
                  reticleRef.current.children[0].material.color.setHex(0xff0000);
                } else {
                   reticleRef.current.children[0].material.color.setHex(0x00ffff);
                }

                if (Math.hypot(thumbTip.x - indexMCP.x, thumbTip.y - indexMCP.y) < 0.12) {
                  if (!isTriggeredRef.current) {
                     if (Date.now() - lastShotTimeRef.current > 120) { isShooting = true; lastShotTimeRef.current = Date.now(); }
                     isTriggeredRef.current = true;
                  }
                } else {
                  isTriggeredRef.current = false;
                }

                reticleRef.current.visible = true;
                reticleRef.current.position.copy(aimPoint);
                reticleRef.current.lookAt(cameraRef.current.position);
                reticleRef.current.scale.setScalar(cameraRef.current.position.distanceTo(aimPoint) * 0.03);

                const pos = laserRef.current.geometry.attributes.position.array;
                pos[0] = handPos.x; pos[1] = handPos.y - 0.2; pos[2] = handPos.z;
                pos[3] = aimPoint.x; pos[4] = aimPoint.y; pos[5] = aimPoint.z;
                laserRef.current.geometry.attributes.position.needsUpdate = true;

                if (isShooting) {
                  generateSound('shoot');
                  if (navigator.vibrate) navigator.vibrate(30);
                  recoilRef.current.x = (Math.random() - 0.5) * 0.4;
                  recoilRef.current.y = 0.6; 

                  muzzleFlashRef.current.position.copy(handPos).add(new THREE.Vector3(0,0,-1.5));
                  muzzleFlashRef.current.lookAt(aimPoint);
                  muzzleFlashRef.current.visible = true;
                  setTimeout(() => { if(muzzleFlashRef.current) muzzleFlashRef.current.visible = false; }, 60);

                  if (closestTarget) {
                     scene.remove(closestTarget);
                     targetsRef.current = targetsRef.current.filter(t => t !== closestTarget);
                     scoreRef.current += 1;
                     onScoreUpdate(scoreRef.current);
                     generateSound('hit');
                     if (navigator.vibrate) navigator.vibrate([30, 50]);
                     
                     const vector = closestTarget.position.clone().project(cameraRef.current);
                     const x = (vector.x * .5 + .5) * containerRef.current.clientWidth;
                     const y = (-(vector.y * .5) + .5) * containerRef.current.clientHeight;
                     addFloatingText(x, y, "DESTROYED", "hit");
                  }
                }
              } else {
                 reticleRef.current.visible = false;
                 laserRef.current.geometry.attributes.position.array.fill(0);
                 laserRef.current.geometry.attributes.position.needsUpdate = true;
              }
            }

            renderer.render(scene, cameraRef.current);
            animationFrameId = requestAnimationFrame(loop);
          };

          animationFrameId = requestAnimationFrame(loop);

          const handleResize = () => {
              if (!containerRef.current || !cameraRef.current) return;
              const w = containerRef.current.clientWidth || window.innerWidth;
              const h = containerRef.current.clientHeight || window.innerHeight;
              cameraRef.current.aspect = w / h;
              cameraRef.current.updateProjectionMatrix();
              rendererRef.current.setSize(w, h);
          };
          window.addEventListener('resize', handleResize);
          handleResize();

          return () => {
            window.removeEventListener('resize', handleResize);
            cancelAnimationFrame(animationFrameId);
            if(handsRef.current) handsRef.current.close();
            if(sceneRef.current) sceneRef.current.clear();
            if(rendererRef.current) rendererRef.current.dispose();
            const s = videoRef.current?.srcObject;
            s?.getTracks().forEach(t => t.stop());
          };
        }, [gameState, onScoreUpdate]);

        return (
          <div ref={containerRef} className="absolute inset-0 w-full h-full bg-[#0f1923] overflow-hidden">
            <div className="absolute inset-0 pointer-events-none z-10 opacity-60" style={{ background: 'radial-gradient(circle at center, transparent 30%, #000 120%)' }}></div>
            <div className="absolute top-20 left-10 w-64 h-px bg-white/20 z-10 hidden md:block"></div>
            <div className="absolute bottom-20 right-10 w-64 h-px bg-white/20 z-10 hidden md:block"></div>
            
            <video ref={videoRef} className="hidden" playsInline muted autoPlay></video>
            <canvas ref={canvasRef} className="block w-full h-full" />
            
            {!initialized && (
              <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm cursor-pointer" onClick={startSystem}>
                  <div className="border-2 border-[#ff4655] p-10 text-center animate-pulse">
                      <h1 className="text-4xl text-[#ff4655] font-val font-bold mb-4">SYSTEM OFFLINE</h1>
                      <p className="text-white text-xl font-val tracking-widest">TAP TO INITIALIZE</p>
                  </div>
              </div>
            )}

            {initialized && (
              <div className="absolute bottom-4 right-4 w-40 h-32 md:w-56 md:h-40 z-20 border border-[#ff4655] bg-black/80 shadow-[0_0_10px_#ff4655]">
                 <canvas ref={trackingCanvasRef} width={320} height={240} className="w-full h-full object-cover tracking-scanline opacity-80" />
                 <div className="absolute bottom-0 w-full bg-[#ff4655] text-black text-[10px] font-bold px-1 font-val flex justify-between">
                    <span>TARGETING SYS: {cameraReady ? 'ONLINE' : 'SEARCHING...'}</span>
                    <span>FPS: 60</span>
                 </div>
              </div>
            )}

            <div className="absolute top-2 left-2 z-40 font-mono text-[10px] text-green-400 pointer-events-none opacity-70">
              {logs.map((l, i) => <div key={i}>{l}</div>)}
              {cameraError && <div className="text-red-500 font-bold bg-black/50 p-1">{cameraError}</div>}
            </div>

            {floatingTexts.map(ft => (
              <div key={ft.id} className="absolute font-val font-bold text-6xl pointer-events-none"
                   style={{ 
                     left: ft.x, top: ft.y, 
                     color: ft.type === 'hit' ? '#ff4655' : '#fff',
                     textShadow: ft.type === 'hit' ? '0 0 20px #ff4655' : '0 0 10px #fff',
                     animation: 'floatUp 0.6s ease-out forwards'
                   }}>
                 {ft.text}
              </div>
            ))}
            <style>{`@keyframes floatUp { 0% { opacity: 0; transform: translate(-50%, 0) scale(0.5); } 20% { opacity: 1; transform: translate(-50%, -20px) scale(1.2); } 100% { opacity: 0; transform: translate(-50%, -80px) scale(1); } }`}</style>
          </div>
        );
      }

      // --- MAIN APP ---
      const GameState = { MENU: 0, PLAYING: 1, GAME_OVER: 2 };

      function App() {
        const [gameState, setGameState] = useState(GameState.MENU);
        const [score, setScore] = useState(0);

        const startGame = () => {
          generateSound('ui');
          setScore(0);
          setGameState(GameState.PLAYING);
        };

        const endGame = (finalScore) => {
          setScore(finalScore);
          setGameState(GameState.GAME_OVER);
        };

        return (
          <div className="relative w-full h-full text-white font-val overflow-hidden">
            <ARGame gameState={gameState} onScoreUpdate={setScore} onGameOver={endGame} />
            
            <div id="ui-layer" className="flex flex-col justify-between p-6">
              <div className="flex justify-between items-start w-full">
                <div className="flex flex-col">
                  <h1 className="text-3xl md:text-5xl font-bold tracking-wider text-[#ff4655] drop-shadow-md uppercase">无畏契约</h1>
                  <span className="text-xl md:text-2xl text-white tracking-widest opacity-80">小琳特供版</span>
                </div>
                {gameState === GameState.PLAYING && (
                  <div className="flex flex-col items-end">
                    <span className="text-sm text-gray-400 tracking-widest">KILLS</span>
                    <span className="text-6xl font-bold text-white drop-shadow-[0_0_10px_rgba(255,70,85,0.5)]">{score}</span>
                  </div>
                )}
              </div>

              <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-md text-center pointer-events-auto">
                {gameState === GameState.MENU && (
                  <div className="bg-[#0f1923]/90 border border-[#ff4655] p-8 backdrop-blur-md animate-fade-in">
                    <p className="text-gray-300 mb-6 text-lg">Use your hand as a pistol.<br/><span className="text-[#ff4655]">Index finger</span> to aim.<br/><span className="text-[#ff4655]">Thumb</span> to shoot.</p>
                    <button onClick={startGame} className="bg-[#ff4655] hover:bg-[#d93442] text-white text-2xl font-bold py-3 px-12 transition-all duration-200 active:scale-95" style={{ clipPath: 'polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%)' }}>START MISSION</button>
                  </div>
                )}

                {gameState === GameState.GAME_OVER && (
                  <div className="bg-[#0f1923]/90 border border-[#ff4655] p-8 backdrop-blur-md animate-fade-in">
                    <h2 className="text-5xl font-bold text-white mb-2 uppercase">Mission Over</h2>
                    <div className="w-full h-px bg-gray-600 my-4"></div>
                    <div className="flex justify-between items-center mb-8 px-4">
                      <span className="text-gray-400 text-xl">FINAL SCORE</span>
                      <span className="text-[#ff4655] text-4xl font-bold">{score}</span>
                    </div>
                    <button onClick={startGame} className="bg-white hover:bg-gray-200 text-[#0f1923] text-2xl font-bold py-3 px-12 transition-all duration-200 active:scale-95" style={{ clipPath: 'polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%)' }}>PLAY AGAIN</button>
                  </div>
                )}
              </div>
              <div className="text-center text-xs text-gray-500 opacity-50">AR GESTURE SYSTEM ONLINE • V 1.0</div>
            </div>
          </div>
        );
      }

      // --- ROOT ---
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>